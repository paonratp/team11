// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/team11/app/ent/migrate"

	"github.com/team11/app/ent/author"
	"github.com/team11/app/ent/book"
	"github.com/team11/app/ent/bookborrow"
	"github.com/team11/app/ent/booking"
	"github.com/team11/app/ent/bookreturn"
	"github.com/team11/app/ent/category"
	"github.com/team11/app/ent/cliententity"
	"github.com/team11/app/ent/location"
	"github.com/team11/app/ent/preemption"
	"github.com/team11/app/ent/purpose"
	"github.com/team11/app/ent/research"
	"github.com/team11/app/ent/researchtype"
	"github.com/team11/app/ent/role"
	"github.com/team11/app/ent/roominfo"
	"github.com/team11/app/ent/servicepoint"
	"github.com/team11/app/ent/status"
	"github.com/team11/app/ent/user"

	"github.com/facebookincubator/ent/dialect"
	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Author is the client for interacting with the Author builders.
	Author *AuthorClient
	// Book is the client for interacting with the Book builders.
	Book *BookClient
	// Bookborrow is the client for interacting with the Bookborrow builders.
	Bookborrow *BookborrowClient
	// Booking is the client for interacting with the Booking builders.
	Booking *BookingClient
	// Bookreturn is the client for interacting with the Bookreturn builders.
	Bookreturn *BookreturnClient
	// Category is the client for interacting with the Category builders.
	Category *CategoryClient
	// ClientEntity is the client for interacting with the ClientEntity builders.
	ClientEntity *ClientEntityClient
	// Location is the client for interacting with the Location builders.
	Location *LocationClient
	// Preemption is the client for interacting with the Preemption builders.
	Preemption *PreemptionClient
	// Purpose is the client for interacting with the Purpose builders.
	Purpose *PurposeClient
	// Research is the client for interacting with the Research builders.
	Research *ResearchClient
	// Researchtype is the client for interacting with the Researchtype builders.
	Researchtype *ResearchtypeClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// Roominfo is the client for interacting with the Roominfo builders.
	Roominfo *RoominfoClient
	// ServicePoint is the client for interacting with the ServicePoint builders.
	ServicePoint *ServicePointClient
	// Status is the client for interacting with the Status builders.
	Status *StatusClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Author = NewAuthorClient(c.config)
	c.Book = NewBookClient(c.config)
	c.Bookborrow = NewBookborrowClient(c.config)
	c.Booking = NewBookingClient(c.config)
	c.Bookreturn = NewBookreturnClient(c.config)
	c.Category = NewCategoryClient(c.config)
	c.ClientEntity = NewClientEntityClient(c.config)
	c.Location = NewLocationClient(c.config)
	c.Preemption = NewPreemptionClient(c.config)
	c.Purpose = NewPurposeClient(c.config)
	c.Research = NewResearchClient(c.config)
	c.Researchtype = NewResearchtypeClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.Roominfo = NewRoominfoClient(c.config)
	c.ServicePoint = NewServicePointClient(c.config)
	c.Status = NewStatusClient(c.config)
	c.User = NewUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		ctx:          ctx,
		config:       cfg,
		Author:       NewAuthorClient(cfg),
		Book:         NewBookClient(cfg),
		Bookborrow:   NewBookborrowClient(cfg),
		Booking:      NewBookingClient(cfg),
		Bookreturn:   NewBookreturnClient(cfg),
		Category:     NewCategoryClient(cfg),
		ClientEntity: NewClientEntityClient(cfg),
		Location:     NewLocationClient(cfg),
		Preemption:   NewPreemptionClient(cfg),
		Purpose:      NewPurposeClient(cfg),
		Research:     NewResearchClient(cfg),
		Researchtype: NewResearchtypeClient(cfg),
		Role:         NewRoleClient(cfg),
		Roominfo:     NewRoominfoClient(cfg),
		ServicePoint: NewServicePointClient(cfg),
		Status:       NewStatusClient(cfg),
		User:         NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(*sql.Driver).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: &txDriver{tx: tx, drv: c.driver}, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:       cfg,
		Author:       NewAuthorClient(cfg),
		Book:         NewBookClient(cfg),
		Bookborrow:   NewBookborrowClient(cfg),
		Booking:      NewBookingClient(cfg),
		Bookreturn:   NewBookreturnClient(cfg),
		Category:     NewCategoryClient(cfg),
		ClientEntity: NewClientEntityClient(cfg),
		Location:     NewLocationClient(cfg),
		Preemption:   NewPreemptionClient(cfg),
		Purpose:      NewPurposeClient(cfg),
		Research:     NewResearchClient(cfg),
		Researchtype: NewResearchtypeClient(cfg),
		Role:         NewRoleClient(cfg),
		Roominfo:     NewRoominfoClient(cfg),
		ServicePoint: NewServicePointClient(cfg),
		Status:       NewStatusClient(cfg),
		User:         NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Author.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Author.Use(hooks...)
	c.Book.Use(hooks...)
	c.Bookborrow.Use(hooks...)
	c.Booking.Use(hooks...)
	c.Bookreturn.Use(hooks...)
	c.Category.Use(hooks...)
	c.ClientEntity.Use(hooks...)
	c.Location.Use(hooks...)
	c.Preemption.Use(hooks...)
	c.Purpose.Use(hooks...)
	c.Research.Use(hooks...)
	c.Researchtype.Use(hooks...)
	c.Role.Use(hooks...)
	c.Roominfo.Use(hooks...)
	c.ServicePoint.Use(hooks...)
	c.Status.Use(hooks...)
	c.User.Use(hooks...)
}

// AuthorClient is a client for the Author schema.
type AuthorClient struct {
	config
}

// NewAuthorClient returns a client for the Author from the given config.
func NewAuthorClient(c config) *AuthorClient {
	return &AuthorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `author.Hooks(f(g(h())))`.
func (c *AuthorClient) Use(hooks ...Hook) {
	c.hooks.Author = append(c.hooks.Author, hooks...)
}

// Create returns a create builder for Author.
func (c *AuthorClient) Create() *AuthorCreate {
	mutation := newAuthorMutation(c.config, OpCreate)
	return &AuthorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Author.
func (c *AuthorClient) Update() *AuthorUpdate {
	mutation := newAuthorMutation(c.config, OpUpdate)
	return &AuthorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthorClient) UpdateOne(a *Author) *AuthorUpdateOne {
	mutation := newAuthorMutation(c.config, OpUpdateOne, withAuthor(a))
	return &AuthorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthorClient) UpdateOneID(id int) *AuthorUpdateOne {
	mutation := newAuthorMutation(c.config, OpUpdateOne, withAuthorID(id))
	return &AuthorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Author.
func (c *AuthorClient) Delete() *AuthorDelete {
	mutation := newAuthorMutation(c.config, OpDelete)
	return &AuthorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AuthorClient) DeleteOne(a *Author) *AuthorDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AuthorClient) DeleteOneID(id int) *AuthorDeleteOne {
	builder := c.Delete().Where(author.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthorDeleteOne{builder}
}

// Create returns a query builder for Author.
func (c *AuthorClient) Query() *AuthorQuery {
	return &AuthorQuery{config: c.config}
}

// Get returns a Author entity by its id.
func (c *AuthorClient) Get(ctx context.Context, id int) (*Author, error) {
	return c.Query().Where(author.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthorClient) GetX(ctx context.Context, id int) *Author {
	a, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return a
}

// QueryOwner queries the owner edge of a Author.
func (c *AuthorClient) QueryOwner(a *Author) *ResearchQuery {
	query := &ResearchQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(author.Table, author.FieldID, id),
			sqlgraph.To(research.Table, research.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, author.OwnerTable, author.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWriter queries the writer edge of a Author.
func (c *AuthorClient) QueryWriter(a *Author) *BookQuery {
	query := &BookQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(author.Table, author.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, author.WriterTable, author.WriterColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthorClient) Hooks() []Hook {
	return c.hooks.Author
}

// BookClient is a client for the Book schema.
type BookClient struct {
	config
}

// NewBookClient returns a client for the Book from the given config.
func NewBookClient(c config) *BookClient {
	return &BookClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `book.Hooks(f(g(h())))`.
func (c *BookClient) Use(hooks ...Hook) {
	c.hooks.Book = append(c.hooks.Book, hooks...)
}

// Create returns a create builder for Book.
func (c *BookClient) Create() *BookCreate {
	mutation := newBookMutation(c.config, OpCreate)
	return &BookCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Book.
func (c *BookClient) Update() *BookUpdate {
	mutation := newBookMutation(c.config, OpUpdate)
	return &BookUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookClient) UpdateOne(b *Book) *BookUpdateOne {
	mutation := newBookMutation(c.config, OpUpdateOne, withBook(b))
	return &BookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookClient) UpdateOneID(id int) *BookUpdateOne {
	mutation := newBookMutation(c.config, OpUpdateOne, withBookID(id))
	return &BookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Book.
func (c *BookClient) Delete() *BookDelete {
	mutation := newBookMutation(c.config, OpDelete)
	return &BookDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *BookClient) DeleteOne(b *Book) *BookDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *BookClient) DeleteOneID(id int) *BookDeleteOne {
	builder := c.Delete().Where(book.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookDeleteOne{builder}
}

// Create returns a query builder for Book.
func (c *BookClient) Query() *BookQuery {
	return &BookQuery{config: c.config}
}

// Get returns a Book entity by its id.
func (c *BookClient) Get(ctx context.Context, id int) (*Book, error) {
	return c.Query().Where(book.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookClient) GetX(ctx context.Context, id int) *Book {
	b, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return b
}

// QueryCategory queries the category edge of a Book.
func (c *BookClient) QueryCategory(b *Book) *CategoryQuery {
	query := &CategoryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, book.CategoryTable, book.CategoryColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthor queries the author edge of a Book.
func (c *BookClient) QueryAuthor(b *Book) *AuthorQuery {
	query := &AuthorQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(author.Table, author.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, book.AuthorTable, book.AuthorColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Book.
func (c *BookClient) QueryUser(b *Book) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, book.UserTable, book.UserColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatus queries the Status edge of a Book.
func (c *BookClient) QueryStatus(b *Book) *StatusQuery {
	query := &StatusQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, book.StatusTable, book.StatusColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBooklist queries the booklist edge of a Book.
func (c *BookClient) QueryBooklist(b *Book) *BookborrowQuery {
	query := &BookborrowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(book.Table, book.FieldID, id),
			sqlgraph.To(bookborrow.Table, bookborrow.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, book.BooklistTable, book.BooklistColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BookClient) Hooks() []Hook {
	return c.hooks.Book
}

// BookborrowClient is a client for the Bookborrow schema.
type BookborrowClient struct {
	config
}

// NewBookborrowClient returns a client for the Bookborrow from the given config.
func NewBookborrowClient(c config) *BookborrowClient {
	return &BookborrowClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bookborrow.Hooks(f(g(h())))`.
func (c *BookborrowClient) Use(hooks ...Hook) {
	c.hooks.Bookborrow = append(c.hooks.Bookborrow, hooks...)
}

// Create returns a create builder for Bookborrow.
func (c *BookborrowClient) Create() *BookborrowCreate {
	mutation := newBookborrowMutation(c.config, OpCreate)
	return &BookborrowCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Bookborrow.
func (c *BookborrowClient) Update() *BookborrowUpdate {
	mutation := newBookborrowMutation(c.config, OpUpdate)
	return &BookborrowUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookborrowClient) UpdateOne(b *Bookborrow) *BookborrowUpdateOne {
	mutation := newBookborrowMutation(c.config, OpUpdateOne, withBookborrow(b))
	return &BookborrowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookborrowClient) UpdateOneID(id int) *BookborrowUpdateOne {
	mutation := newBookborrowMutation(c.config, OpUpdateOne, withBookborrowID(id))
	return &BookborrowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Bookborrow.
func (c *BookborrowClient) Delete() *BookborrowDelete {
	mutation := newBookborrowMutation(c.config, OpDelete)
	return &BookborrowDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *BookborrowClient) DeleteOne(b *Bookborrow) *BookborrowDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *BookborrowClient) DeleteOneID(id int) *BookborrowDeleteOne {
	builder := c.Delete().Where(bookborrow.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookborrowDeleteOne{builder}
}

// Create returns a query builder for Bookborrow.
func (c *BookborrowClient) Query() *BookborrowQuery {
	return &BookborrowQuery{config: c.config}
}

// Get returns a Bookborrow entity by its id.
func (c *BookborrowClient) Get(ctx context.Context, id int) (*Bookborrow, error) {
	return c.Query().Where(bookborrow.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookborrowClient) GetX(ctx context.Context, id int) *Bookborrow {
	b, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return b
}

// QueryUSER queries the USER edge of a Bookborrow.
func (c *BookborrowClient) QueryUSER(b *Bookborrow) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bookborrow.Table, bookborrow.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bookborrow.USERTable, bookborrow.USERColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBOOK queries the BOOK edge of a Bookborrow.
func (c *BookborrowClient) QueryBOOK(b *Bookborrow) *BookQuery {
	query := &BookQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bookborrow.Table, bookborrow.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bookborrow.BOOKTable, bookborrow.BOOKColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySERVICEPOINT queries the SERVICEPOINT edge of a Bookborrow.
func (c *BookborrowClient) QuerySERVICEPOINT(b *Bookborrow) *ServicePointQuery {
	query := &ServicePointQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bookborrow.Table, bookborrow.FieldID, id),
			sqlgraph.To(servicepoint.Table, servicepoint.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bookborrow.SERVICEPOINTTable, bookborrow.SERVICEPOINTColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BookborrowClient) Hooks() []Hook {
	return c.hooks.Bookborrow
}

// BookingClient is a client for the Booking schema.
type BookingClient struct {
	config
}

// NewBookingClient returns a client for the Booking from the given config.
func NewBookingClient(c config) *BookingClient {
	return &BookingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `booking.Hooks(f(g(h())))`.
func (c *BookingClient) Use(hooks ...Hook) {
	c.hooks.Booking = append(c.hooks.Booking, hooks...)
}

// Create returns a create builder for Booking.
func (c *BookingClient) Create() *BookingCreate {
	mutation := newBookingMutation(c.config, OpCreate)
	return &BookingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Booking.
func (c *BookingClient) Update() *BookingUpdate {
	mutation := newBookingMutation(c.config, OpUpdate)
	return &BookingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookingClient) UpdateOne(b *Booking) *BookingUpdateOne {
	mutation := newBookingMutation(c.config, OpUpdateOne, withBooking(b))
	return &BookingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookingClient) UpdateOneID(id int) *BookingUpdateOne {
	mutation := newBookingMutation(c.config, OpUpdateOne, withBookingID(id))
	return &BookingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Booking.
func (c *BookingClient) Delete() *BookingDelete {
	mutation := newBookingMutation(c.config, OpDelete)
	return &BookingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *BookingClient) DeleteOne(b *Booking) *BookingDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *BookingClient) DeleteOneID(id int) *BookingDeleteOne {
	builder := c.Delete().Where(booking.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookingDeleteOne{builder}
}

// Create returns a query builder for Booking.
func (c *BookingClient) Query() *BookingQuery {
	return &BookingQuery{config: c.config}
}

// Get returns a Booking entity by its id.
func (c *BookingClient) Get(ctx context.Context, id int) (*Booking, error) {
	return c.Query().Where(booking.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookingClient) GetX(ctx context.Context, id int) *Booking {
	b, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return b
}

// QueryUsedby queries the usedby edge of a Booking.
func (c *BookingClient) QueryUsedby(b *Booking) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, booking.UsedbyTable, booking.UsedbyColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGetservice queries the getservice edge of a Booking.
func (c *BookingClient) QueryGetservice(b *Booking) *ServicePointQuery {
	query := &ServicePointQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(servicepoint.Table, servicepoint.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, booking.GetserviceTable, booking.GetserviceColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsing queries the using edge of a Booking.
func (c *BookingClient) QueryUsing(b *Booking) *ClientEntityQuery {
	query := &ClientEntityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(booking.Table, booking.FieldID, id),
			sqlgraph.To(cliententity.Table, cliententity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, booking.UsingTable, booking.UsingColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BookingClient) Hooks() []Hook {
	return c.hooks.Booking
}

// BookreturnClient is a client for the Bookreturn schema.
type BookreturnClient struct {
	config
}

// NewBookreturnClient returns a client for the Bookreturn from the given config.
func NewBookreturnClient(c config) *BookreturnClient {
	return &BookreturnClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bookreturn.Hooks(f(g(h())))`.
func (c *BookreturnClient) Use(hooks ...Hook) {
	c.hooks.Bookreturn = append(c.hooks.Bookreturn, hooks...)
}

// Create returns a create builder for Bookreturn.
func (c *BookreturnClient) Create() *BookreturnCreate {
	mutation := newBookreturnMutation(c.config, OpCreate)
	return &BookreturnCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Bookreturn.
func (c *BookreturnClient) Update() *BookreturnUpdate {
	mutation := newBookreturnMutation(c.config, OpUpdate)
	return &BookreturnUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookreturnClient) UpdateOne(b *Bookreturn) *BookreturnUpdateOne {
	mutation := newBookreturnMutation(c.config, OpUpdateOne, withBookreturn(b))
	return &BookreturnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookreturnClient) UpdateOneID(id int) *BookreturnUpdateOne {
	mutation := newBookreturnMutation(c.config, OpUpdateOne, withBookreturnID(id))
	return &BookreturnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Bookreturn.
func (c *BookreturnClient) Delete() *BookreturnDelete {
	mutation := newBookreturnMutation(c.config, OpDelete)
	return &BookreturnDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *BookreturnClient) DeleteOne(b *Bookreturn) *BookreturnDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *BookreturnClient) DeleteOneID(id int) *BookreturnDeleteOne {
	builder := c.Delete().Where(bookreturn.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookreturnDeleteOne{builder}
}

// Create returns a query builder for Bookreturn.
func (c *BookreturnClient) Query() *BookreturnQuery {
	return &BookreturnQuery{config: c.config}
}

// Get returns a Bookreturn entity by its id.
func (c *BookreturnClient) Get(ctx context.Context, id int) (*Bookreturn, error) {
	return c.Query().Where(bookreturn.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookreturnClient) GetX(ctx context.Context, id int) *Bookreturn {
	b, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return b
}

// Hooks returns the client hooks.
func (c *BookreturnClient) Hooks() []Hook {
	return c.hooks.Bookreturn
}

// CategoryClient is a client for the Category schema.
type CategoryClient struct {
	config
}

// NewCategoryClient returns a client for the Category from the given config.
func NewCategoryClient(c config) *CategoryClient {
	return &CategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `category.Hooks(f(g(h())))`.
func (c *CategoryClient) Use(hooks ...Hook) {
	c.hooks.Category = append(c.hooks.Category, hooks...)
}

// Create returns a create builder for Category.
func (c *CategoryClient) Create() *CategoryCreate {
	mutation := newCategoryMutation(c.config, OpCreate)
	return &CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Category.
func (c *CategoryClient) Update() *CategoryUpdate {
	mutation := newCategoryMutation(c.config, OpUpdate)
	return &CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CategoryClient) UpdateOne(ca *Category) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategory(ca))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CategoryClient) UpdateOneID(id int) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategoryID(id))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Category.
func (c *CategoryClient) Delete() *CategoryDelete {
	mutation := newCategoryMutation(c.config, OpDelete)
	return &CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CategoryClient) DeleteOne(ca *Category) *CategoryDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CategoryClient) DeleteOneID(id int) *CategoryDeleteOne {
	builder := c.Delete().Where(category.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CategoryDeleteOne{builder}
}

// Create returns a query builder for Category.
func (c *CategoryClient) Query() *CategoryQuery {
	return &CategoryQuery{config: c.config}
}

// Get returns a Category entity by its id.
func (c *CategoryClient) Get(ctx context.Context, id int) (*Category, error) {
	return c.Query().Where(category.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CategoryClient) GetX(ctx context.Context, id int) *Category {
	ca, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return ca
}

// QueryCatof queries the catof edge of a Category.
func (c *CategoryClient) QueryCatof(ca *Category) *BookQuery {
	query := &BookQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, category.CatofTable, category.CatofColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CategoryClient) Hooks() []Hook {
	return c.hooks.Category
}

// ClientEntityClient is a client for the ClientEntity schema.
type ClientEntityClient struct {
	config
}

// NewClientEntityClient returns a client for the ClientEntity from the given config.
func NewClientEntityClient(c config) *ClientEntityClient {
	return &ClientEntityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cliententity.Hooks(f(g(h())))`.
func (c *ClientEntityClient) Use(hooks ...Hook) {
	c.hooks.ClientEntity = append(c.hooks.ClientEntity, hooks...)
}

// Create returns a create builder for ClientEntity.
func (c *ClientEntityClient) Create() *ClientEntityCreate {
	mutation := newClientEntityMutation(c.config, OpCreate)
	return &ClientEntityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for ClientEntity.
func (c *ClientEntityClient) Update() *ClientEntityUpdate {
	mutation := newClientEntityMutation(c.config, OpUpdate)
	return &ClientEntityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClientEntityClient) UpdateOne(ce *ClientEntity) *ClientEntityUpdateOne {
	mutation := newClientEntityMutation(c.config, OpUpdateOne, withClientEntity(ce))
	return &ClientEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClientEntityClient) UpdateOneID(id int) *ClientEntityUpdateOne {
	mutation := newClientEntityMutation(c.config, OpUpdateOne, withClientEntityID(id))
	return &ClientEntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ClientEntity.
func (c *ClientEntityClient) Delete() *ClientEntityDelete {
	mutation := newClientEntityMutation(c.config, OpDelete)
	return &ClientEntityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ClientEntityClient) DeleteOne(ce *ClientEntity) *ClientEntityDeleteOne {
	return c.DeleteOneID(ce.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ClientEntityClient) DeleteOneID(id int) *ClientEntityDeleteOne {
	builder := c.Delete().Where(cliententity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClientEntityDeleteOne{builder}
}

// Create returns a query builder for ClientEntity.
func (c *ClientEntityClient) Query() *ClientEntityQuery {
	return &ClientEntityQuery{config: c.config}
}

// Get returns a ClientEntity entity by its id.
func (c *ClientEntityClient) Get(ctx context.Context, id int) (*ClientEntity, error) {
	return c.Query().Where(cliententity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClientEntityClient) GetX(ctx context.Context, id int) *ClientEntity {
	ce, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return ce
}

// QueryBooked queries the booked edge of a ClientEntity.
func (c *ClientEntityClient) QueryBooked(ce *ClientEntity) *BookingQuery {
	query := &BookingQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cliententity.Table, cliententity.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, cliententity.BookedTable, cliententity.BookedColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryState queries the state edge of a ClientEntity.
func (c *ClientEntityClient) QueryState(ce *ClientEntity) *StatusQuery {
	query := &StatusQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cliententity.Table, cliententity.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, cliententity.StateTable, cliententity.StateColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClientEntityClient) Hooks() []Hook {
	return c.hooks.ClientEntity
}

// LocationClient is a client for the Location schema.
type LocationClient struct {
	config
}

// NewLocationClient returns a client for the Location from the given config.
func NewLocationClient(c config) *LocationClient {
	return &LocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `location.Hooks(f(g(h())))`.
func (c *LocationClient) Use(hooks ...Hook) {
	c.hooks.Location = append(c.hooks.Location, hooks...)
}

// Create returns a create builder for Location.
func (c *LocationClient) Create() *LocationCreate {
	mutation := newLocationMutation(c.config, OpCreate)
	return &LocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Location.
func (c *LocationClient) Update() *LocationUpdate {
	mutation := newLocationMutation(c.config, OpUpdate)
	return &LocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LocationClient) UpdateOne(l *Location) *LocationUpdateOne {
	mutation := newLocationMutation(c.config, OpUpdateOne, withLocation(l))
	return &LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LocationClient) UpdateOneID(id int) *LocationUpdateOne {
	mutation := newLocationMutation(c.config, OpUpdateOne, withLocationID(id))
	return &LocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Location.
func (c *LocationClient) Delete() *LocationDelete {
	mutation := newLocationMutation(c.config, OpDelete)
	return &LocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *LocationClient) DeleteOne(l *Location) *LocationDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *LocationClient) DeleteOneID(id int) *LocationDeleteOne {
	builder := c.Delete().Where(location.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LocationDeleteOne{builder}
}

// Create returns a query builder for Location.
func (c *LocationClient) Query() *LocationQuery {
	return &LocationQuery{config: c.config}
}

// Get returns a Location entity by its id.
func (c *LocationClient) Get(ctx context.Context, id int) (*Location, error) {
	return c.Query().Where(location.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LocationClient) GetX(ctx context.Context, id int) *Location {
	l, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return l
}

// QueryLocations queries the locations edge of a Location.
func (c *LocationClient) QueryLocations(l *Location) *BookreturnQuery {
	query := &BookreturnQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(location.Table, location.FieldID, id),
			sqlgraph.To(bookreturn.Table, bookreturn.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, location.LocationsTable, location.LocationsColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LocationClient) Hooks() []Hook {
	return c.hooks.Location
}

// PreemptionClient is a client for the Preemption schema.
type PreemptionClient struct {
	config
}

// NewPreemptionClient returns a client for the Preemption from the given config.
func NewPreemptionClient(c config) *PreemptionClient {
	return &PreemptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `preemption.Hooks(f(g(h())))`.
func (c *PreemptionClient) Use(hooks ...Hook) {
	c.hooks.Preemption = append(c.hooks.Preemption, hooks...)
}

// Create returns a create builder for Preemption.
func (c *PreemptionClient) Create() *PreemptionCreate {
	mutation := newPreemptionMutation(c.config, OpCreate)
	return &PreemptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Preemption.
func (c *PreemptionClient) Update() *PreemptionUpdate {
	mutation := newPreemptionMutation(c.config, OpUpdate)
	return &PreemptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PreemptionClient) UpdateOne(pr *Preemption) *PreemptionUpdateOne {
	mutation := newPreemptionMutation(c.config, OpUpdateOne, withPreemption(pr))
	return &PreemptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PreemptionClient) UpdateOneID(id int) *PreemptionUpdateOne {
	mutation := newPreemptionMutation(c.config, OpUpdateOne, withPreemptionID(id))
	return &PreemptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Preemption.
func (c *PreemptionClient) Delete() *PreemptionDelete {
	mutation := newPreemptionMutation(c.config, OpDelete)
	return &PreemptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PreemptionClient) DeleteOne(pr *Preemption) *PreemptionDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PreemptionClient) DeleteOneID(id int) *PreemptionDeleteOne {
	builder := c.Delete().Where(preemption.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PreemptionDeleteOne{builder}
}

// Create returns a query builder for Preemption.
func (c *PreemptionClient) Query() *PreemptionQuery {
	return &PreemptionQuery{config: c.config}
}

// Get returns a Preemption entity by its id.
func (c *PreemptionClient) Get(ctx context.Context, id int) (*Preemption, error) {
	return c.Query().Where(preemption.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PreemptionClient) GetX(ctx context.Context, id int) *Preemption {
	pr, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pr
}

// QueryUserID queries the User_ID edge of a Preemption.
func (c *PreemptionClient) QueryUserID(pr *Preemption) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(preemption.Table, preemption.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, preemption.UserIDTable, preemption.UserIDColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPurposeID queries the PurposeID edge of a Preemption.
func (c *PreemptionClient) QueryPurposeID(pr *Preemption) *PurposeQuery {
	query := &PurposeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(preemption.Table, preemption.FieldID, id),
			sqlgraph.To(purpose.Table, purpose.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, preemption.PurposeIDTable, preemption.PurposeIDColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoomID queries the RoomID edge of a Preemption.
func (c *PreemptionClient) QueryRoomID(pr *Preemption) *RoominfoQuery {
	query := &RoominfoQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(preemption.Table, preemption.FieldID, id),
			sqlgraph.To(roominfo.Table, roominfo.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, preemption.RoomIDTable, preemption.RoomIDColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PreemptionClient) Hooks() []Hook {
	return c.hooks.Preemption
}

// PurposeClient is a client for the Purpose schema.
type PurposeClient struct {
	config
}

// NewPurposeClient returns a client for the Purpose from the given config.
func NewPurposeClient(c config) *PurposeClient {
	return &PurposeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `purpose.Hooks(f(g(h())))`.
func (c *PurposeClient) Use(hooks ...Hook) {
	c.hooks.Purpose = append(c.hooks.Purpose, hooks...)
}

// Create returns a create builder for Purpose.
func (c *PurposeClient) Create() *PurposeCreate {
	mutation := newPurposeMutation(c.config, OpCreate)
	return &PurposeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Purpose.
func (c *PurposeClient) Update() *PurposeUpdate {
	mutation := newPurposeMutation(c.config, OpUpdate)
	return &PurposeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PurposeClient) UpdateOne(pu *Purpose) *PurposeUpdateOne {
	mutation := newPurposeMutation(c.config, OpUpdateOne, withPurpose(pu))
	return &PurposeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PurposeClient) UpdateOneID(id int) *PurposeUpdateOne {
	mutation := newPurposeMutation(c.config, OpUpdateOne, withPurposeID(id))
	return &PurposeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Purpose.
func (c *PurposeClient) Delete() *PurposeDelete {
	mutation := newPurposeMutation(c.config, OpDelete)
	return &PurposeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *PurposeClient) DeleteOne(pu *Purpose) *PurposeDeleteOne {
	return c.DeleteOneID(pu.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *PurposeClient) DeleteOneID(id int) *PurposeDeleteOne {
	builder := c.Delete().Where(purpose.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PurposeDeleteOne{builder}
}

// Create returns a query builder for Purpose.
func (c *PurposeClient) Query() *PurposeQuery {
	return &PurposeQuery{config: c.config}
}

// Get returns a Purpose entity by its id.
func (c *PurposeClient) Get(ctx context.Context, id int) (*Purpose, error) {
	return c.Query().Where(purpose.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PurposeClient) GetX(ctx context.Context, id int) *Purpose {
	pu, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return pu
}

// QueryPreemption queries the preemption edge of a Purpose.
func (c *PurposeClient) QueryPreemption(pu *Purpose) *PreemptionQuery {
	query := &PreemptionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := pu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(purpose.Table, purpose.FieldID, id),
			sqlgraph.To(preemption.Table, preemption.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, purpose.PreemptionTable, purpose.PreemptionColumn),
		)
		fromV = sqlgraph.Neighbors(pu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PurposeClient) Hooks() []Hook {
	return c.hooks.Purpose
}

// ResearchClient is a client for the Research schema.
type ResearchClient struct {
	config
}

// NewResearchClient returns a client for the Research from the given config.
func NewResearchClient(c config) *ResearchClient {
	return &ResearchClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `research.Hooks(f(g(h())))`.
func (c *ResearchClient) Use(hooks ...Hook) {
	c.hooks.Research = append(c.hooks.Research, hooks...)
}

// Create returns a create builder for Research.
func (c *ResearchClient) Create() *ResearchCreate {
	mutation := newResearchMutation(c.config, OpCreate)
	return &ResearchCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Research.
func (c *ResearchClient) Update() *ResearchUpdate {
	mutation := newResearchMutation(c.config, OpUpdate)
	return &ResearchUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResearchClient) UpdateOne(r *Research) *ResearchUpdateOne {
	mutation := newResearchMutation(c.config, OpUpdateOne, withResearch(r))
	return &ResearchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResearchClient) UpdateOneID(id int) *ResearchUpdateOne {
	mutation := newResearchMutation(c.config, OpUpdateOne, withResearchID(id))
	return &ResearchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Research.
func (c *ResearchClient) Delete() *ResearchDelete {
	mutation := newResearchMutation(c.config, OpDelete)
	return &ResearchDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ResearchClient) DeleteOne(r *Research) *ResearchDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ResearchClient) DeleteOneID(id int) *ResearchDeleteOne {
	builder := c.Delete().Where(research.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResearchDeleteOne{builder}
}

// Create returns a query builder for Research.
func (c *ResearchClient) Query() *ResearchQuery {
	return &ResearchQuery{config: c.config}
}

// Get returns a Research entity by its id.
func (c *ResearchClient) Get(ctx context.Context, id int) (*Research, error) {
	return c.Query().Where(research.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResearchClient) GetX(ctx context.Context, id int) *Research {
	r, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return r
}

// QueryRegister queries the register edge of a Research.
func (c *ResearchClient) QueryRegister(r *Research) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(research.Table, research.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, research.RegisterTable, research.RegisterColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMyDoc queries the myDoc edge of a Research.
func (c *ResearchClient) QueryMyDoc(r *Research) *AuthorQuery {
	query := &AuthorQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(research.Table, research.FieldID, id),
			sqlgraph.To(author.Table, author.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, research.MyDocTable, research.MyDocColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocType queries the docType edge of a Research.
func (c *ResearchClient) QueryDocType(r *Research) *ResearchtypeQuery {
	query := &ResearchtypeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(research.Table, research.FieldID, id),
			sqlgraph.To(researchtype.Table, researchtype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, research.DocTypeTable, research.DocTypeColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResearchClient) Hooks() []Hook {
	return c.hooks.Research
}

// ResearchtypeClient is a client for the Researchtype schema.
type ResearchtypeClient struct {
	config
}

// NewResearchtypeClient returns a client for the Researchtype from the given config.
func NewResearchtypeClient(c config) *ResearchtypeClient {
	return &ResearchtypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `researchtype.Hooks(f(g(h())))`.
func (c *ResearchtypeClient) Use(hooks ...Hook) {
	c.hooks.Researchtype = append(c.hooks.Researchtype, hooks...)
}

// Create returns a create builder for Researchtype.
func (c *ResearchtypeClient) Create() *ResearchtypeCreate {
	mutation := newResearchtypeMutation(c.config, OpCreate)
	return &ResearchtypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Researchtype.
func (c *ResearchtypeClient) Update() *ResearchtypeUpdate {
	mutation := newResearchtypeMutation(c.config, OpUpdate)
	return &ResearchtypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ResearchtypeClient) UpdateOne(r *Researchtype) *ResearchtypeUpdateOne {
	mutation := newResearchtypeMutation(c.config, OpUpdateOne, withResearchtype(r))
	return &ResearchtypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ResearchtypeClient) UpdateOneID(id int) *ResearchtypeUpdateOne {
	mutation := newResearchtypeMutation(c.config, OpUpdateOne, withResearchtypeID(id))
	return &ResearchtypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Researchtype.
func (c *ResearchtypeClient) Delete() *ResearchtypeDelete {
	mutation := newResearchtypeMutation(c.config, OpDelete)
	return &ResearchtypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ResearchtypeClient) DeleteOne(r *Researchtype) *ResearchtypeDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ResearchtypeClient) DeleteOneID(id int) *ResearchtypeDeleteOne {
	builder := c.Delete().Where(researchtype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ResearchtypeDeleteOne{builder}
}

// Create returns a query builder for Researchtype.
func (c *ResearchtypeClient) Query() *ResearchtypeQuery {
	return &ResearchtypeQuery{config: c.config}
}

// Get returns a Researchtype entity by its id.
func (c *ResearchtypeClient) Get(ctx context.Context, id int) (*Researchtype, error) {
	return c.Query().Where(researchtype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ResearchtypeClient) GetX(ctx context.Context, id int) *Researchtype {
	r, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return r
}

// QueryResearchType queries the researchType edge of a Researchtype.
func (c *ResearchtypeClient) QueryResearchType(r *Researchtype) *ResearchQuery {
	query := &ResearchQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(researchtype.Table, researchtype.FieldID, id),
			sqlgraph.To(research.Table, research.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, researchtype.ResearchTypeTable, researchtype.ResearchTypeColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ResearchtypeClient) Hooks() []Hook {
	return c.hooks.Researchtype
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Create returns a create builder for Role.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(r *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(r))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id int) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *RoleClient) DeleteOne(r *Role) *RoleDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *RoleClient) DeleteOneID(id int) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Create returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{config: c.config}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id int) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id int) *Role {
	r, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return r
}

// QueryRole queries the role edge of a Role.
func (c *RoleClient) QueryRole(r *Role) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, role.RoleTable, role.RoleColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	return c.hooks.Role
}

// RoominfoClient is a client for the Roominfo schema.
type RoominfoClient struct {
	config
}

// NewRoominfoClient returns a client for the Roominfo from the given config.
func NewRoominfoClient(c config) *RoominfoClient {
	return &RoominfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `roominfo.Hooks(f(g(h())))`.
func (c *RoominfoClient) Use(hooks ...Hook) {
	c.hooks.Roominfo = append(c.hooks.Roominfo, hooks...)
}

// Create returns a create builder for Roominfo.
func (c *RoominfoClient) Create() *RoominfoCreate {
	mutation := newRoominfoMutation(c.config, OpCreate)
	return &RoominfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Roominfo.
func (c *RoominfoClient) Update() *RoominfoUpdate {
	mutation := newRoominfoMutation(c.config, OpUpdate)
	return &RoominfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoominfoClient) UpdateOne(r *Roominfo) *RoominfoUpdateOne {
	mutation := newRoominfoMutation(c.config, OpUpdateOne, withRoominfo(r))
	return &RoominfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoominfoClient) UpdateOneID(id int) *RoominfoUpdateOne {
	mutation := newRoominfoMutation(c.config, OpUpdateOne, withRoominfoID(id))
	return &RoominfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Roominfo.
func (c *RoominfoClient) Delete() *RoominfoDelete {
	mutation := newRoominfoMutation(c.config, OpDelete)
	return &RoominfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *RoominfoClient) DeleteOne(r *Roominfo) *RoominfoDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *RoominfoClient) DeleteOneID(id int) *RoominfoDeleteOne {
	builder := c.Delete().Where(roominfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoominfoDeleteOne{builder}
}

// Create returns a query builder for Roominfo.
func (c *RoominfoClient) Query() *RoominfoQuery {
	return &RoominfoQuery{config: c.config}
}

// Get returns a Roominfo entity by its id.
func (c *RoominfoClient) Get(ctx context.Context, id int) (*Roominfo, error) {
	return c.Query().Where(roominfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoominfoClient) GetX(ctx context.Context, id int) *Roominfo {
	r, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return r
}

// QueryPreemption queries the preemption edge of a Roominfo.
func (c *RoominfoClient) QueryPreemption(r *Roominfo) *PreemptionQuery {
	query := &PreemptionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(roominfo.Table, roominfo.FieldID, id),
			sqlgraph.To(preemption.Table, preemption.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, roominfo.PreemptionTable, roominfo.PreemptionColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoominfoClient) Hooks() []Hook {
	return c.hooks.Roominfo
}

// ServicePointClient is a client for the ServicePoint schema.
type ServicePointClient struct {
	config
}

// NewServicePointClient returns a client for the ServicePoint from the given config.
func NewServicePointClient(c config) *ServicePointClient {
	return &ServicePointClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `servicepoint.Hooks(f(g(h())))`.
func (c *ServicePointClient) Use(hooks ...Hook) {
	c.hooks.ServicePoint = append(c.hooks.ServicePoint, hooks...)
}

// Create returns a create builder for ServicePoint.
func (c *ServicePointClient) Create() *ServicePointCreate {
	mutation := newServicePointMutation(c.config, OpCreate)
	return &ServicePointCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for ServicePoint.
func (c *ServicePointClient) Update() *ServicePointUpdate {
	mutation := newServicePointMutation(c.config, OpUpdate)
	return &ServicePointUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServicePointClient) UpdateOne(sp *ServicePoint) *ServicePointUpdateOne {
	mutation := newServicePointMutation(c.config, OpUpdateOne, withServicePoint(sp))
	return &ServicePointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServicePointClient) UpdateOneID(id int) *ServicePointUpdateOne {
	mutation := newServicePointMutation(c.config, OpUpdateOne, withServicePointID(id))
	return &ServicePointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServicePoint.
func (c *ServicePointClient) Delete() *ServicePointDelete {
	mutation := newServicePointMutation(c.config, OpDelete)
	return &ServicePointDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ServicePointClient) DeleteOne(sp *ServicePoint) *ServicePointDeleteOne {
	return c.DeleteOneID(sp.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ServicePointClient) DeleteOneID(id int) *ServicePointDeleteOne {
	builder := c.Delete().Where(servicepoint.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServicePointDeleteOne{builder}
}

// Create returns a query builder for ServicePoint.
func (c *ServicePointClient) Query() *ServicePointQuery {
	return &ServicePointQuery{config: c.config}
}

// Get returns a ServicePoint entity by its id.
func (c *ServicePointClient) Get(ctx context.Context, id int) (*ServicePoint, error) {
	return c.Query().Where(servicepoint.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServicePointClient) GetX(ctx context.Context, id int) *ServicePoint {
	sp, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return sp
}

// QueryFrom queries the from edge of a ServicePoint.
func (c *ServicePointClient) QueryFrom(sp *ServicePoint) *BookborrowQuery {
	query := &BookborrowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := sp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servicepoint.Table, servicepoint.FieldID, id),
			sqlgraph.To(bookborrow.Table, bookborrow.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, servicepoint.FromTable, servicepoint.FromColumn),
		)
		fromV = sqlgraph.Neighbors(sp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServicepoint queries the servicepoint edge of a ServicePoint.
func (c *ServicePointClient) QueryServicepoint(sp *ServicePoint) *BookingQuery {
	query := &BookingQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := sp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servicepoint.Table, servicepoint.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, servicepoint.ServicepointTable, servicepoint.ServicepointColumn),
		)
		fromV = sqlgraph.Neighbors(sp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServicePointClient) Hooks() []Hook {
	return c.hooks.ServicePoint
}

// StatusClient is a client for the Status schema.
type StatusClient struct {
	config
}

// NewStatusClient returns a client for the Status from the given config.
func NewStatusClient(c config) *StatusClient {
	return &StatusClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `status.Hooks(f(g(h())))`.
func (c *StatusClient) Use(hooks ...Hook) {
	c.hooks.Status = append(c.hooks.Status, hooks...)
}

// Create returns a create builder for Status.
func (c *StatusClient) Create() *StatusCreate {
	mutation := newStatusMutation(c.config, OpCreate)
	return &StatusCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for Status.
func (c *StatusClient) Update() *StatusUpdate {
	mutation := newStatusMutation(c.config, OpUpdate)
	return &StatusUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StatusClient) UpdateOne(s *Status) *StatusUpdateOne {
	mutation := newStatusMutation(c.config, OpUpdateOne, withStatus(s))
	return &StatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StatusClient) UpdateOneID(id int) *StatusUpdateOne {
	mutation := newStatusMutation(c.config, OpUpdateOne, withStatusID(id))
	return &StatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Status.
func (c *StatusClient) Delete() *StatusDelete {
	mutation := newStatusMutation(c.config, OpDelete)
	return &StatusDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *StatusClient) DeleteOne(s *Status) *StatusDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *StatusClient) DeleteOneID(id int) *StatusDeleteOne {
	builder := c.Delete().Where(status.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StatusDeleteOne{builder}
}

// Create returns a query builder for Status.
func (c *StatusClient) Query() *StatusQuery {
	return &StatusQuery{config: c.config}
}

// Get returns a Status entity by its id.
func (c *StatusClient) Get(ctx context.Context, id int) (*Status, error) {
	return c.Query().Where(status.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StatusClient) GetX(ctx context.Context, id int) *Status {
	s, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return s
}

// QueryStatus queries the status edge of a Status.
func (c *StatusClient) QueryStatus(s *Status) *ClientEntityQuery {
	query := &ClientEntityQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(cliententity.Table, cliententity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, status.StatusTable, status.StatusColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatusofbook queries the statusofbook edge of a Status.
func (c *StatusClient) QueryStatusofbook(s *Status) *BookQuery {
	query := &BookQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, status.StatusofbookTable, status.StatusofbookColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StatusClient) Hooks() []Hook {
	return c.hooks.Status
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Create returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{config: c.config}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	u, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return u
}

// QueryPosition queries the position edge of a User.
func (c *UserClient) QueryPosition(u *User) *RoleQuery {
	query := &RoleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.PositionTable, user.PositionColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBooking queries the booking edge of a User.
func (c *UserClient) QueryBooking(u *User) *BookingQuery {
	query := &BookingQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(booking.Table, booking.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.BookingTable, user.BookingColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAddby queries the addby edge of a User.
func (c *UserClient) QueryAddby(u *User) *BookQuery {
	query := &BookQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(book.Table, book.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AddbyTable, user.AddbyColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBorrow queries the borrow edge of a User.
func (c *UserClient) QueryBorrow(u *User) *BookborrowQuery {
	query := &BookborrowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(bookborrow.Table, bookborrow.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.BorrowTable, user.BorrowColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPreemption queries the preemption edge of a User.
func (c *UserClient) QueryPreemption(u *User) *PreemptionQuery {
	query := &PreemptionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(preemption.Table, preemption.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PreemptionTable, user.PreemptionColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRecord queries the record edge of a User.
func (c *UserClient) QueryRecord(u *User) *ResearchQuery {
	query := &ResearchQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(research.Table, research.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.RecordTable, user.RecordColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}
